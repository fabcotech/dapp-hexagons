!function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=10)}([function(n,e){n.exports=React},function(n,e){n.exports=ReactDOM},function(n,e,t){const{erc1155Term:r}=t(3),{createTokensTerm:a}=t(4),{purchaseTokensTerm:o}=t(5),{sendTokensTerm:i}=t(6),{setLockedTerm:u}=t(7),{updateTokenDataTerm:s}=t(8),{updateBagDataTerm:c}=t(9);n.exports={erc1155Term:r,createTokensTerm:a,purchaseTokensTerm:o,sendTokensTerm:i,setLockedTerm:u,updateTokenDataTerm:s,updateBagDataTerm:c}},function(n,e){n.exports.erc1155Term=(n,e)=>`new \n  mainCh,\n  createCh,\n  purchaseCh,\n  sendCh,\n  entryCh,\n  entryUriCh,\n  setLockedCh,\n  updateTokenDataCh,\n  updateBagDataCh,\n  updateUriCh,\n  bags,\n  bagsData,\n  tokensData,\n  verifySignatureAndUpdateNonceCh,\n  justVerifySignatureCh,\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\n  stdout(\`rho:io:stdout\`),\n  secpVerify(\`rho:crypto:secp256k1Verify\`),\n  blake2b256(\`rho:crypto:blake2b256Hash\`),\n  revAddress(\`rho:rev:address\`),\n  registryLookup(\`rho:registry:lookup\`)\nin {\n\n\n  /*\n    bags: {\n      [bagId: String (incremental id)]: {\n        publicKey: String (public key),\n        n: Nil \\/ String (token id),\n        price: Nil \\/ Int\n        quantity: Int\n      }\n    }\n  */\n  bags!({/*DEFAULT_BAGS*/}) |\n\n  /*\n    bagsData: {\n      [bagId: String (bag id)]: Any\n    }\n  */\n  bagsData!({/*DEFAULT_BAGS_DATA*/}) |\n\n  /*\n    tokensData: {\n      [n: Strig (token id)]: String (registry URI)\n    }\n  */\n  tokensData!({/*DEFAULT_TOKENS_DATA*/}) |\n\n  for (@(payload, returnCh) <= verifySignatureAndUpdateNonceCh) {\n    stdout!("verifySignatureAndUpdateNonceCh") |\n    new hashCh, verifySignatureCh in {\n      match payload {\n        { "newNonce": String, "signature": String} => {\n          for (@current <<- mainCh) {\n            blake2b256!(\n              current.get("nonce").toUtf8Bytes(),\n              *hashCh\n            ) |\n            for (@hash <- hashCh) {\n              secpVerify!(\n                hash,\n                payload.get("signature").hexToBytes(),\n                current.get("publicKey").hexToBytes(),\n                *verifySignatureCh\n              )\n            } |\n            for (@result <- verifySignatureCh) {\n              match result {\n                true => {\n                  @returnCh!(true) |\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("nonce", payload.get("newNonce")))\n                  }\n                }\n                false => {\n                  @returnCh!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n        _ => {\n          @returnCh!("error: invalid payload, structure should be { 'newNonce': String, 'signature': String }")\n        }\n      }\n    }\n  } |\n\n  for (@(publicKey, signature, nonce, returnCh) <= justVerifySignatureCh) {\n    stdout!("justVerifySignatureCh") |\n    new hashCh, verifySignatureCh in {\n      blake2b256!(\n        nonce.toUtf8Bytes(),\n        *hashCh\n      ) |\n      for (@hash <- hashCh) {\n        secpVerify!(\n          hash,\n          signature.hexToBytes(),\n          publicKey.hexToBytes(),\n          *verifySignatureCh\n        )\n      } |\n      for (@result <- verifySignatureCh) {\n        @returnCh!(result)\n      }\n    }\n  } |\n\n  contract setLockedCh(payload, return) = {\n    stdout!("setLockedCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is already locked")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              {\n                "newNonce": *payload.get("newNonce"),\n                "signature": *payload.get("signature"),\n              },\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("locked", true))\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateTokenDataCh(payload, return) = {\n    stdout!("updateTokenDataCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot update token data")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              {\n                "newNonce": *payload.get("newNonce"),\n                "signature": *payload.get("signature"),\n              },\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentTokensData <- tokensData) {\n                    tokensData!(\n                      currentTokensData.set(*payload.get("n"), *payload.get("data"))\n                    )\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateBagDataCh(payload, return) = {\n    stdout!("updateBagDataCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          new verifyCh in {\n            justVerifySignatureCh!((\n              bag.get("publicKey"),\n              *payload.get("signature"),\n              bag.get("nonce"),\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentBagsData <- bagsData) {\n                    bagsData!(\n                      currentBagsData.set(*payload.get("bagId"), *payload.get("data"))\n                    ) |\n                    return!(true)\n                  }\n                }\n                err => {\n                  return!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // add a token (1 or more)\n  contract createCh(payload, return) = {\n    stdout!("createCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot create token")\n        }\n        false => {\n          for (@currentBags <<- bags) {\n            new verifyCh in {\n              verifySignatureAndUpdateNonceCh!((\n                {\n                  "newNonce": *payload.get("newNonce"),\n                  "signature": *payload.get("signature"),\n                },\n                *verifyCh\n              )) |\n              for (@verified <- verifyCh) {\n                match verified {\n                  true => {\n                    match "\${n}" %% { "n": currentBags.size() } {\n                      bagId => {\n                        new nCh in {\n\n                          match *payload.get("n") {\n                            // token n already exists\n                            String => { nCh!(*payload.get("n")) }\n                            // token n does not exist, bag ID will be used as n\n                            _ => { nCh!(bagId) }\n                          } |\n\n                          for (@n <- nCh) {\n                            for (_ <- bags) {\n                              bags!(\n                                currentBags.set(bagId, {\n                                  "quantity": *payload.get("quantity"),\n                                  "publicKey": *payload.get("publicKey"),\n                                  "nonce": *payload.get("bagNonce"),\n                                  "n": n,\n                                  "price": *payload.get("price"),\n                                })\n                              ) \n                            } |\n\n                            match *payload.get("data") {\n                              Nil => {}\n                              data => {\n                                for (@currentTokensData <- tokensData) {\n                                  tokensData!(\n                                    currentTokensData.set(n, data)\n                                  )\n                                }\n                              }\n                            } |\n\n                            return!(true)\n                          }\n                        }\n                      }\n                    }\n                  }\n                  err => {\n                    return!(err)\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // purchase token (1 or more)\n  contract purchaseCh(payload, return) = {\n    stdout!("purchaseCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            false => {\n              return!("error : not enough tokens in bag (bag ID: " ++ *payload.get("bagId") ++ ") available")\n            }\n            true => {\n              new RevVaultCh, ownerRevAddressCh in {\n\n                registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n                revAddress!("fromPublicKey", bag.get("publicKey").hexToBytes(), *ownerRevAddressCh) |\n\n                for (@(_, RevVault) <- RevVaultCh; @ownerRevAddress <- ownerRevAddressCh) {\n                  match (\n                    *payload.get("purseRevAddr"),\n                    ownerRevAddress,\n                    *payload.get("quantity") * bag.get("price")\n                  ) {\n                    (from, to, amount) => {\n                      new purseVaultCh in {\n                        @RevVault!("findOrCreate", from, *purseVaultCh) |\n                        for (@(true, purseVault) <- purseVaultCh) {\n\n                          new resultCh in {\n                            @purseVault!("transfer", to, amount, *payload.get("purseAuthKey"), *resultCh) |\n                            for (@result <- resultCh) {\n\n                              match result {\n                                (true, Nil) => {\n                                  match "\${bagId}" %% { "bagId": currentBags.size() } {\n                                    bagId => {\n                                      match *payload.get("data") {\n                                        Nil => {}\n                                        data => {\n                                          for (@currentBagsData <- bagsData) {\n                                            bagsData!(currentBagsData.set(bagId, data))\n                                          }\n                                        }\n                                      } |\n                                      for (_ <- bags) {\n                                        bags!(\n                                          // New bag ID for new token ownership\n                                          currentBags.set(bagId, {\n                                            "quantity": *payload.get("quantity"),\n                                            "publicKey": *payload.get("publicKey"),\n                                            "nonce": *payload.get("nonce"),\n                                            "n": bag.get("n"),\n                                            "price": Nil,\n                                          // Udate quantity in seller token ownership\n                                          }).set(\n                                            *payload.get("bagId"),\n                                            bag.set("quantity", bag.get("quantity") - *payload.get("quantity"))\n                                          )\n                                        ) |\n                                        return!(true)\n                                      }\n                                    }\n                                  }\n                                }\n                                _ => {\n                                  bags!(currentBags) |\n                                  return!("error : REV transfer went wrong " ++ result.nth(2))\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract sendCh(payload, return) = {\n    stdout!("sendCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            true => {\n              new justVerifySignatureReturnCh in {\n                justVerifySignatureCh!((\n                  bag.get("publicKey"),\n                  *payload.get("signature"),\n                  bag.get("nonce"),\n                  *justVerifySignatureCh\n                )) |\n                for (@r <- justVerifySignatureCh) {\n                  stdout!(r) |\n                  match r {\n                    true => {\n                      match "\${bagId}" %% { "bagId": currentBags.size() } {\n                        bagId => {\n                          // Add bag data if found in payload\n                          match *payload.get("data") {\n                            Nil => {}\n                            data => {\n                              for (@currentBagsData <- bagsData) {\n                                bagsData!(currentBagsData.set(bagId, data))\n                              }\n                            }\n                          } |\n                          for (_ <- bags) {\n                            bags!(\n                              // New bag ID for new token ownership\n                              currentBags.set(bagId, {\n                                "quantity": *payload.get("quantity"),\n                                "publicKey": *payload.get("publicKey"),\n                                "nonce": *payload.get("bagNonce"),\n                                "n": bag.get("n"),\n                                "price": Nil,\n                              // Udate quantity in seller token ownership\n                              }).set(\n                                *payload.get("bagId"),\n                                bag.set(\n                                  "quantity", bag.get("quantity") - *payload.get("quantity")\n                                ).set(\n                                  "nonce",\n                                  *payload.get("bagNonce2")\n                                )\n                              )\n                            )\n                          } |\n                          return!(true)\n                        }\n                      }\n                    }\n                    false => {\n                      return!("error: Invalid signature, could not perform operation")\n                    }\n                  }\n                }\n              }\n            }\n            false => {\n              return!("error : not enough tokens in bag (bag ID) " ++ *payload.get("bagId") ++ " available")\n            }\n          }\n        }\n      }\n    }\n  } |\n  \n  contract entryCh(action, return) = {\n    match *action.get("type") {\n      // Read capabilities\n      "READ_BAGS" => {\n        for (currentBags <<- bags) {\n          return!(*currentBags)\n        }\n      }\n      "READ_BAGS_DATA" => {\n        for (currentBagsData <<- bagsData) {\n          return!(*currentBagsData)\n        }\n      }\n      "READ_TOKENS_DATA" => {\n        for (@currentTokensData <<- tokensData) {\n          return!(currentTokensData)\n        }\n      }\n      "READ" => {\n        for (current <<- mainCh) {\n          return!(*current)\n        }\n      }\n      // Admin capabilities (require a signature of the nonce)\n      "SET_LOCKED" => {\n        match *action.get("payload") {\n          { "locked": true, "signature": String, "newNonce": String } => {\n            setLockedCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'locked': Boolean }")\n          }\n        }\n      }\n      "UPDATE_TOKEN_DATA" => {\n        match *action.get("payload") {\n          { "signature": String, "newNonce": String, "n": String, "data": _ } => {\n            updateTokenDataCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'n': String, 'data': _ }")\n          }\n        }\n      }\n      "UPDATE_BAG_DATA" => {\n        match *action.get("payload") {\n          { "signature": String, "newNonce": String, "bagId": String, "data": _ } => {\n            updateBagDataCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'bagId': String, 'data': _ }")\n          }\n        }\n      }\n      "CREATE_TOKENS" => {\n        match *action.get("payload") {\n          {\n            "signature": String,\n            "newNonce": String,\n            "bagNonce": String,\n            "quantity": Int,\n            "publicKey": String,\n            "price": Nil \\/ Int,\n            "n": Nil \\/ String,\n            "data": _\n          } => {\n            createCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'bagNonce': String, 'quantity': Int, 'n': Nil or String, 'price': Nil or Int, 'publicKey': String, 'data': Any }")\n          }\n        }\n      }\n      // Anyone capabilities\n      "PURCHASE_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "nonce": String, "data": _, "purseRevAddr": _, "purseAuthKey": _ } => {\n            purchaseCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': String, 'publicKey': String, 'nonce': String, 'data': Any, 'purseRevAddr': String, 'purseAuthKey': AuthKey }")\n          }\n        }\n      }\n      "SEND_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "signature": String, "bagNonce": String, "bagNonce2": String, "data": _, } => {\n            sendCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': Int, 'publicKey': String, 'signature': String, 'bagNonce': String, 'bagNonce2': String, 'data': Any }")\n          }\n        }\n      }\n      _ => {\n        return!("error: unknown action")\n      }\n    }\n  } |\n\n  insertArbitrary!(*entryCh, *entryUriCh) |\n\n  for (entryUri <- entryUriCh) {\n\n    mainCh!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${e}",\n      "nonce": "${n}",\n      "version": "0.3"\n    }) |\n    stdout!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${e}",\n      "nonce": "${n}",\n      "version": "0.3"\n    })\n\n    /*OUTPUT_CHANNEL*/\n  }\n}\n`},function(n,e){n.exports.createTokensTerm=(n,e,t,r,a,o,i,u,s)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${n}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "CREATE_TOKENS",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${e}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t}",\n          // new nonce for the bag, must be random (generateNonce.js)\n          "bagNonce": "${r}",\n          // per token price, can be Nil if the token is not for sale\n          "price": ${i||"Nil"},\n          // The token you create can be a new one ("n" : Nil)\n          // or it can be linked to an existing token data (ex: "n": "0")\n          "n": ${"string"==typeof o?'"'+o+'"':"Nil"},\n          // quantity of tokens to create\n          "quantity": ${u},\n          // publicKey this set of tokens (depending on quantity) will belong to\n          "publicKey": "${a}", // used only if new token\n          // data is used only if new token ("n" : Nil)\n          "data": ${s?'"'+encodeURI(s)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, token created") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(n,e){n.exports.purchaseTokensTerm=(n,e,t,r,a,o,i)=>`\nnew\n  revVaultPurseCh,\n  priceCh,\n  quantityCh,\n  publicKeyCh,\n  nonceCh,\n  bagDataCh,\n  returnCh,\n  bagIdCh,\n  registryUriCh,\n  revAddressCh,\n  registryLookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`),\n  revAddress(\`rho:rev:address\`)\nin {\n\n  /*\n    The 5 following values must be filled with proper values\n  */ \n  // Registry URI of the ERC-1155 contract\n  registryUriCh!!(\`rho:id:${n}\`) |\n  // Unique ID of the token you want to purchase\n  bagIdCh!!("${e}") |\n  // Per token price, make sure it is accurate\n  priceCh!!(${t||"Nil"}) |\n  // Bag data: Any\n  bagDataCh!!(${r?'"'+encodeURI(r)+'"':"Nil"}) |\n  // Quantity you want to purchase, make sure enough are available\n  quantityCh!!(${a}) |\n  // Your public key\n  publicKeyCh!!("${o}") |\n  // A unique nonce to be changed on each operation\n  nonceCh!!("${i}") |\n\n  registryLookup!(\`rho:rchain:revVault\`, *revVaultPurseCh) |\n\n  /*\n    Create a vault/purse that is just used once (purse)\n  */\n  for(@(_, *RevVaultPurse) <- revVaultPurseCh) {\n    new unf, purseRevAddrCh, purseAuthKeyCh, vaultCh, revAddressCh in {\n      revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |\n      RevVaultPurse!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |\n      for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {\n\n        stdout!({"new purse rev addr": purseRevAddr, "purse authKey": purseAuthKey}) |\n\n        RevVaultPurse!("findOrCreate", purseRevAddr, *vaultCh) |\n\n        for (\n          @(true, *vault) <- vaultCh;\n          @publicKey <- publicKeyCh;\n          @nonce <- nonceCh;\n          @bagId <- bagIdCh;\n          @registryUri <- registryUriCh;\n          @price <- priceCh;\n          @bagData <- bagDataCh;\n          @quantity <- quantityCh\n        ) {\n\n          revAddress!("fromPublicKey", publicKey.hexToBytes(), *revAddressCh) |\n\n          new RevVaultCh in {\n\n            registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n            for (@(_, RevVault) <- RevVaultCh; deployerRevAddress <- revAddressCh) {\n\n              stdout!(("3.transfer_funds.rho")) |\n\n              /*\n                Put price * quantity REV in the purse\n              */\n              match (\n                *deployerRevAddress,\n                purseRevAddr,\n                price * quantity\n              ) {\n                (from, to, amount) => {\n\n                  new vaultCh, revVaultkeyCh, deployerId(\`rho:rchain:deployerId\`) in {\n                    @RevVault!("findOrCreate", from, *vaultCh) |\n                    @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |\n                    for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {\n\n                      stdout!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |\n\n                      new resultCh, entryCh in {\n                        @vault!("transfer", to, amount, *key, *resultCh) |\n                        for (@result <- resultCh) {\n\n                          stdout!(("Finished transfer of ", amount, "REV to", to, "result was:", result)) |\n                          match result {\n                            (true, Nil) => {\n                              stdout!("yes") |\n                              registryLookup!(registryUri, *entryCh) |\n\n                              for(entry <- entryCh) {\n                                stdout!(("GET ENTRY", *entry)) |\n                                entry!(\n                                  {\n                                    "type": "PURCHASE_TOKENS",\n                                    "payload": {\n                                      "quantity": quantity,\n                                      "bagId": bagId,\n                                      "data": bagData,\n                                      "nonce": nonce,\n                                      "publicKey": publicKey,\n                                      "purseRevAddr": purseRevAddr,\n                                      "purseAuthKey": purseAuthKey\n                                    }\n                                  },\n                                  *returnCh\n                                ) |\n                                for (resp <- returnCh) {\n                                  match *resp {\n                                    String => { stdout!(*resp) }\n                                    true => { stdout!("success, purchase successful") }\n                                  }\n                                }\n                              }\n                            }\n                            _ => {\n                              stdout!(result) |\n                              stdout!("no")\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`},function(n,e){n.exports.sendTokensTerm=(n,e,t,r,a,o,i,u)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${n}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SEND_TOKENS",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${e}",\n          // new nonce, must be different and random (generateNonce.js)\n          "bagNonce": "${t}",\n          // new nonce for the new bag\n          "bagNonce2": "${r}",\n          // bag ID (ex: "0")\n          "bagId": "${i}",\n          // quantity of tokens to send\n          "quantity": ${a},\n          // publicKey this send those tokens to (can be the same just split a bag)\n          "publicKey": "${o}",\n          // data (optional) to be attached to the new bag (in bagsData)\n          "data": ${u?'"'+encodeURI(u)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, tokens sent") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(n,e){n.exports.setLockedTerm=(n,e,t)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${n}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SET_LOCKED",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${t}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${e}",\n          //you cannot unlock, this value must always be true\n          "locked": true\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, tokens locked") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(n,e){n.exports.updateTokenDataTerm=(n,e,t,r)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${n}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_TOKEN_DATA",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${signature}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${e}",\n          // token ID you want to attach data to\n          "n": ${"string"==typeof t?'"'+t+'"':"Nil"},\n          // data is used only if new token ("n" : Nil)\n          "data": ${r?'"'+encodeURI(r)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, token data updated") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(n,e){n.exports.updateBagDataTerm=(n,e,t,r,a)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${n}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_BAG_DATA",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${t}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${e}",\n          // bag ID you want to attach data to\n          "bagId": "${r}",\n          // data is used only if new token ("n" : Nil)\n          "data": ${a?'"'+encodeURI(a)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, bag data updated") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(n,e,t){"use strict";t.r(e);var r=t(0),a=t.n(r),o=t(1),i=t.n(o),u=t(2);var s=Math.PI/3,c=[0,s,2*s,3*s,4*s,5*s];function l(n){return n[0]}function h(n){return n[1]}function p(){}var d=function(n){return null==n?p:function(){return this.querySelector(n)}};function f(){return[]}var y=function(n){return new Array(n.length)};function g(n,e){this.ownerDocument=n.ownerDocument,this.namespaceURI=n.namespaceURI,this._next=null,this._parent=n,this.__data__=e}g.prototype={constructor:g,appendChild:function(n){return this._parent.insertBefore(n,this._next)},insertBefore:function(n,e){return this._parent.insertBefore(n,e)},querySelector:function(n){return this._parent.querySelector(n)},querySelectorAll:function(n){return this._parent.querySelectorAll(n)}};function m(n,e,t,r,a,o){for(var i,u=0,s=e.length,c=o.length;u<c;++u)(i=e[u])?(i.__data__=o[u],r[u]=i):t[u]=new g(n,o[u]);for(;u<s;++u)(i=e[u])&&(a[u]=i)}function b(n,e,t,r,a,o,i){var u,s,c,l={},h=e.length,p=o.length,d=new Array(h);for(u=0;u<h;++u)(s=e[u])&&(d[u]=c="$"+i.call(s,s.__data__,u,e),c in l?a[u]=s:l[c]=s);for(u=0;u<p;++u)(s=l[c="$"+i.call(n,o[u],u,o)])?(r[u]=s,s.__data__=o[u],l[c]=null):t[u]=new g(n,o[u]);for(u=0;u<h;++u)(s=e[u])&&l[d[u]]===s&&(a[u]=s)}function v(n,e){return n<e?-1:n>e?1:n>=e?0:NaN}var C="http://www.w3.org/1999/xhtml",w={svg:"http://www.w3.org/2000/svg",xhtml:C,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},_=function(n){var e=n+="",t=e.indexOf(":");return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),w.hasOwnProperty(e)?{space:w[e],local:n}:n};function k(n){return function(){this.removeAttribute(n)}}function S(n){return function(){this.removeAttributeNS(n.space,n.local)}}function N(n,e){return function(){this.setAttribute(n,e)}}function E(n,e){return function(){this.setAttributeNS(n.space,n.local,e)}}function A(n,e){return function(){var t=e.apply(this,arguments);null==t?this.removeAttribute(n):this.setAttribute(n,t)}}function R(n,e){return function(){var t=e.apply(this,arguments);null==t?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,t)}}var D=function(n){return n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView};function T(n){return function(){this.style.removeProperty(n)}}function I(n,e,t){return function(){this.style.setProperty(n,e,t)}}function x(n,e,t){return function(){var r=e.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,t)}}function O(n,e){return n.style.getPropertyValue(e)||D(n).getComputedStyle(n,null).getPropertyValue(e)}function U(n){return function(){delete this[n]}}function B(n,e){return function(){this[n]=e}}function P(n,e){return function(){var t=e.apply(this,arguments);null==t?delete this[n]:this[n]=t}}function j(n){return n.trim().split(/^|\s+/)}function K(n){return n.classList||new V(n)}function V(n){this._node=n,this._names=j(n.getAttribute("class")||"")}function q(n,e){for(var t=K(n),r=-1,a=e.length;++r<a;)t.add(e[r])}function $(n,e){for(var t=K(n),r=-1,a=e.length;++r<a;)t.remove(e[r])}function L(n){return function(){q(this,n)}}function M(n){return function(){$(this,n)}}function F(n,e){return function(){(e.apply(this,arguments)?q:$)(this,n)}}V.prototype={add:function(n){this._names.indexOf(n)<0&&(this._names.push(n),this._node.setAttribute("class",this._names.join(" ")))},remove:function(n){var e=this._names.indexOf(n);e>=0&&(this._names.splice(e,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(n){return this._names.indexOf(n)>=0}};function G(){this.textContent=""}function H(n){return function(){this.textContent=n}}function J(n){return function(){var e=n.apply(this,arguments);this.textContent=null==e?"":e}}function z(){this.innerHTML=""}function Y(n){return function(){this.innerHTML=n}}function X(n){return function(){var e=n.apply(this,arguments);this.innerHTML=null==e?"":e}}function Q(){this.nextSibling&&this.parentNode.appendChild(this)}function W(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function Z(n){return function(){var e=this.ownerDocument,t=this.namespaceURI;return t===C&&e.documentElement.namespaceURI===C?e.createElement(n):e.createElementNS(t,n)}}function nn(n){return function(){return this.ownerDocument.createElementNS(n.space,n.local)}}var en=function(n){var e=_(n);return(e.local?nn:Z)(e)};function tn(){return null}function rn(){var n=this.parentNode;n&&n.removeChild(this)}function an(){var n=this.cloneNode(!1),e=this.parentNode;return e?e.insertBefore(n,this.nextSibling):n}function on(){var n=this.cloneNode(!0),e=this.parentNode;return e?e.insertBefore(n,this.nextSibling):n}var un={},sn=null;"undefined"!=typeof document&&("onmouseenter"in document.documentElement||(un={mouseenter:"mouseover",mouseleave:"mouseout"}));function cn(n,e,t){return n=ln(n,e,t),function(e){var t=e.relatedTarget;t&&(t===this||8&t.compareDocumentPosition(this))||n.call(this,e)}}function ln(n,e,t){return function(r){var a=sn;sn=r;try{n.call(this,this.__data__,e,t)}finally{sn=a}}}function hn(n){return n.trim().split(/^|\s+/).map((function(n){var e="",t=n.indexOf(".");return t>=0&&(e=n.slice(t+1),n=n.slice(0,t)),{type:n,name:e}}))}function pn(n){return function(){var e=this.__on;if(e){for(var t,r=0,a=-1,o=e.length;r<o;++r)t=e[r],n.type&&t.type!==n.type||t.name!==n.name?e[++a]=t:this.removeEventListener(t.type,t.listener,t.capture);++a?e.length=a:delete this.__on}}}function dn(n,e,t){var r=un.hasOwnProperty(n.type)?cn:ln;return function(a,o,i){var u,s=this.__on,c=r(e,o,i);if(s)for(var l=0,h=s.length;l<h;++l)if((u=s[l]).type===n.type&&u.name===n.name)return this.removeEventListener(u.type,u.listener,u.capture),this.addEventListener(u.type,u.listener=c,u.capture=t),void(u.value=e);this.addEventListener(n.type,c,t),u={type:n.type,name:n.name,value:e,listener:c,capture:t},s?s.push(u):this.__on=[u]}}function fn(n,e,t){var r=D(n),a=r.CustomEvent;"function"==typeof a?a=new a(e,t):(a=r.document.createEvent("Event"),t?(a.initEvent(e,t.bubbles,t.cancelable),a.detail=t.detail):a.initEvent(e,!1,!1)),n.dispatchEvent(a)}function yn(n,e){return function(){return fn(this,n,e)}}function gn(n,e){return function(){return fn(this,n,e.apply(this,arguments))}}var mn=[null];function bn(n,e){this._groups=n,this._parents=e}function vn(){return new bn([[document.documentElement]],mn)}bn.prototype=vn.prototype={constructor:bn,select:function(n){"function"!=typeof n&&(n=d(n));for(var e=this._groups,t=e.length,r=new Array(t),a=0;a<t;++a)for(var o,i,u=e[a],s=u.length,c=r[a]=new Array(s),l=0;l<s;++l)(o=u[l])&&(i=n.call(o,o.__data__,l,u))&&("__data__"in o&&(i.__data__=o.__data__),c[l]=i);return new bn(r,this._parents)},selectAll:function(n){var e;"function"!=typeof n&&(n=null==(e=n)?f:function(){return this.querySelectorAll(e)});for(var t=this._groups,r=t.length,a=[],o=[],i=0;i<r;++i)for(var u,s=t[i],c=s.length,l=0;l<c;++l)(u=s[l])&&(a.push(n.call(u,u.__data__,l,s)),o.push(u));return new bn(a,o)},filter:function(n){var e;"function"!=typeof n&&(e=n,n=function(){return this.matches(e)});for(var t=this._groups,r=t.length,a=new Array(r),o=0;o<r;++o)for(var i,u=t[o],s=u.length,c=a[o]=[],l=0;l<s;++l)(i=u[l])&&n.call(i,i.__data__,l,u)&&c.push(i);return new bn(a,this._parents)},data:function(n,e){if(!n)return f=new Array(this.size()),l=-1,this.each((function(n){f[++l]=n})),f;var t,r=e?b:m,a=this._parents,o=this._groups;"function"!=typeof n&&(t=n,n=function(){return t});for(var i=o.length,u=new Array(i),s=new Array(i),c=new Array(i),l=0;l<i;++l){var h=a[l],p=o[l],d=p.length,f=n.call(h,h&&h.__data__,l,a),y=f.length,g=s[l]=new Array(y),v=u[l]=new Array(y);r(h,p,g,v,c[l]=new Array(d),f,e);for(var C,w,_=0,k=0;_<y;++_)if(C=g[_]){for(_>=k&&(k=_+1);!(w=v[k])&&++k<y;);C._next=w||null}}return(u=new bn(u,a))._enter=s,u._exit=c,u},enter:function(){return new bn(this._enter||this._groups.map(y),this._parents)},exit:function(){return new bn(this._exit||this._groups.map(y),this._parents)},join:function(n,e,t){var r=this.enter(),a=this,o=this.exit();return r="function"==typeof n?n(r):r.append(n+""),null!=e&&(a=e(a)),null==t?o.remove():t(o),r&&a?r.merge(a).order():a},merge:function(n){for(var e=this._groups,t=n._groups,r=e.length,a=t.length,o=Math.min(r,a),i=new Array(r),u=0;u<o;++u)for(var s,c=e[u],l=t[u],h=c.length,p=i[u]=new Array(h),d=0;d<h;++d)(s=c[d]||l[d])&&(p[d]=s);for(;u<r;++u)i[u]=e[u];return new bn(i,this._parents)},order:function(){for(var n=this._groups,e=-1,t=n.length;++e<t;)for(var r,a=n[e],o=a.length-1,i=a[o];--o>=0;)(r=a[o])&&(i&&4^r.compareDocumentPosition(i)&&i.parentNode.insertBefore(r,i),i=r);return this},sort:function(n){function e(e,t){return e&&t?n(e.__data__,t.__data__):!e-!t}n||(n=v);for(var t=this._groups,r=t.length,a=new Array(r),o=0;o<r;++o){for(var i,u=t[o],s=u.length,c=a[o]=new Array(s),l=0;l<s;++l)(i=u[l])&&(c[l]=i);c.sort(e)}return new bn(a,this._parents).order()},call:function(){var n=arguments[0];return arguments[0]=this,n.apply(null,arguments),this},nodes:function(){var n=new Array(this.size()),e=-1;return this.each((function(){n[++e]=this})),n},node:function(){for(var n=this._groups,e=0,t=n.length;e<t;++e)for(var r=n[e],a=0,o=r.length;a<o;++a){var i=r[a];if(i)return i}return null},size:function(){var n=0;return this.each((function(){++n})),n},empty:function(){return!this.node()},each:function(n){for(var e=this._groups,t=0,r=e.length;t<r;++t)for(var a,o=e[t],i=0,u=o.length;i<u;++i)(a=o[i])&&n.call(a,a.__data__,i,o);return this},attr:function(n,e){var t=_(n);if(arguments.length<2){var r=this.node();return t.local?r.getAttributeNS(t.space,t.local):r.getAttribute(t)}return this.each((null==e?t.local?S:k:"function"==typeof e?t.local?R:A:t.local?E:N)(t,e))},style:function(n,e,t){return arguments.length>1?this.each((null==e?T:"function"==typeof e?x:I)(n,e,null==t?"":t)):O(this.node(),n)},property:function(n,e){return arguments.length>1?this.each((null==e?U:"function"==typeof e?P:B)(n,e)):this.node()[n]},classed:function(n,e){var t=j(n+"");if(arguments.length<2){for(var r=K(this.node()),a=-1,o=t.length;++a<o;)if(!r.contains(t[a]))return!1;return!0}return this.each(("function"==typeof e?F:e?L:M)(t,e))},text:function(n){return arguments.length?this.each(null==n?G:("function"==typeof n?J:H)(n)):this.node().textContent},html:function(n){return arguments.length?this.each(null==n?z:("function"==typeof n?X:Y)(n)):this.node().innerHTML},raise:function(){return this.each(Q)},lower:function(){return this.each(W)},append:function(n){var e="function"==typeof n?n:en(n);return this.select((function(){return this.appendChild(e.apply(this,arguments))}))},insert:function(n,e){var t="function"==typeof n?n:en(n),r=null==e?tn:"function"==typeof e?e:d(e);return this.select((function(){return this.insertBefore(t.apply(this,arguments),r.apply(this,arguments)||null)}))},remove:function(){return this.each(rn)},clone:function(n){return this.select(n?on:an)},datum:function(n){return arguments.length?this.property("__data__",n):this.node().__data__},on:function(n,e,t){var r,a,o=hn(n+""),i=o.length;if(!(arguments.length<2)){for(u=e?dn:pn,null==t&&(t=!1),r=0;r<i;++r)this.each(u(o[r],e,t));return this}var u=this.node().__on;if(u)for(var s,c=0,l=u.length;c<l;++c)for(r=0,s=u[c];r<i;++r)if((a=o[r]).type===s.type&&a.name===s.name)return s.value},dispatch:function(n,e){return this.each(("function"==typeof e?gn:yn)(n,e))}};var Cn=function(n,e,t,r,a){console.log("createCanvas",n,e),console.log(t),console.log(r);var o={};Object.keys(t).forEach((function(n){r[n]&&r[n].quantity>0&&(o[r[n].n]=decodeURI(t[n]))}));for(var i=15,u=0,p=0,d=15,f=25*n+25,y=25*e+25,g=function(n,e){let t;if(void 0===e)for(const e of n)null!=e&&(t>e||void 0===t&&e>=e)&&(t=e);else{let r=-1;for(let a of n)null!=(a=e(a,++r,n))&&(t>a||void 0===t&&a>=a)&&(t=a)}return t}([f/((n+.5)*Math.sqrt(3)),y/(1.5*(e+1/3))]),m=[],b=0;b<e;b++)for(var v=0;v<n;v++){var C=g*v*Math.sqrt(3);b%2==1&&(C+=g*Math.sqrt(3)/2);var w=g*b*1.5;m.push([C,w])}var _,k=(_="#canvas","string"==typeof _?new bn([[document.querySelector(_)]],[document.documentElement]):new bn([[_]],mn)).append("svg").attr("width",f+d+u).attr("height",y+i+p).append("g").attr("transform","translate("+d+","+i+")"),S=function(){var n,e,t,r=0,a=0,o=1,i=1,u=l,p=h;function d(n){var r,a={},o=[],i=n.length;for(r=0;r<i;++r)if(!isNaN(c=+u.call(null,s=n[r],r,n))&&!isNaN(l=+p.call(null,s,r,n))){var s,c,l,h=Math.round(l/=t),d=Math.round(c=c/e-(1&h)/2),f=l-h;if(3*Math.abs(f)>1){var y=c-d,g=d+(c<d?-1:1)/2,m=h+(l<h?-1:1),b=c-g,v=l-m;y*y+f*f>b*b+v*v&&(d=g+(1&h?1:-1)/2,h=m)}var C=d+"-"+h,w=a[C];w?w.push(s):(o.push(w=a[C]=[s]),w.x=(d+(1&h)/2)*e,w.y=h*t)}return o}function f(n){var e=0,t=0;return c.map((function(r){var a=Math.sin(r)*n,o=-Math.cos(r)*n,i=a-e,u=o-t;return e=a,t=o,[i,u]}))}return d.hexagon=function(e){return"m"+f(null==e?n:+e).join("l")+"z"},d.centers=function(){for(var u=[],s=Math.round(a/t),c=Math.round(r/e),l=s*t;l<i+n;l+=t,++s)for(var h=c*e+(1&s)*e/2;h<o+e/2;h+=e)u.push([h,l]);return u},d.mesh=function(){var e=f(n).slice(0,4).join("l");return d.centers().map((function(n){return"M"+n+"m"+e})).join("")},d.x=function(n){return arguments.length?(u=n,d):u},d.y=function(n){return arguments.length?(p=n,d):p},d.radius=function(r){return arguments.length?(e=2*(n=+r)*Math.sin(s),t=1.5*n,d):n},d.size=function(n){return arguments.length?(r=a=0,o=+n[0],i=+n[1],d):[o-r,i-a]},d.extent=function(n){return arguments.length?(r=+n[0][0],a=+n[0][1],o=+n[1][0],i=+n[1][1],d):[[r,a],[o,i]]},d.radius(1)}().radius(g);k.append("g").selectAll(".hexagon").data(S(m)).enter().append("path").attr("class","hexagon").attr("d",(function(n){return"M"+n.x+","+n.y+S.hexagon()})).attr("n",(function(n,e){return e})).attr("stroke-width","1px").style("stroke",(function(n,e){var t="".concat(e);return o[t]&&/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(o[t]),"#111111"})).style("fill",(function(n,e){var t="".concat(e);return o[t]&&/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(o[t])?o[t]:"rgba(255,255,255,0.5)"})).on("click",a)},wn=new Intl.NumberFormat("en-US",{maximumFractionDigits:8});function _n(n){return(_n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function kn(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function Sn(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Nn(n,e){return(Nn=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function En(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=Dn(n);if(e){var a=Dn(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return An(this,t)}}function An(n,e){return!e||"object"!==_n(e)&&"function"!=typeof e?Rn(n):e}function Rn(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function Dn(n){return(Dn=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function Tn(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}var In=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&Nn(n,e)}(i,n);var e,t,r,o=En(i);function i(){var n;kn(this,i);for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return Tn(Rn(n=o.call.apply(o,[this].concat(t))),"state",{price:1,columns:15,rows:15}),Tn(Rn(n),"onCreateCanvas",(function(){var e=document.getElementById("canvas");e&&"number"==typeof n.state.columns&&"number"==typeof n.state.rows?(e.innerHTML="",Cn(n.state.columns,n.state.rows,{},{},(function(){return null}))):e&&(e.innerHTML="")})),Tn(Rn(n),"onChangeColumns",(function(e){n.setState({columns:parseInt(e.target.value)})})),Tn(Rn(n),"onChangeRows",(function(e){n.setState({rows:parseInt(e.target.value)})})),n}return e=i,(t=[{key:"render",value:function(){var n=this;return console.log(this.state),this.onCreateCanvas(),a.a.createElement("div",{className:"genesis-form form"},a.a.createElement("div",{id:"canvas"}),a.a.createElement("p",null,"Hi ! The canvas is not created, you must define the number of rows, columns, and the price for purchasing one cell (and chosing its color).",a.a.createElement("br",null),a.a.createElement("br",null),"Once you have submitted this form, wait few minutes and reload the page to see the canvas.",a.a.createElement("br",null),a.a.createElement("br",null)),a.a.createElement("div",{class:"field"},a.a.createElement("label",{class:"label"},"Number of rows"),a.a.createElement("div",{class:"control"},a.a.createElement("input",{defaultValue:this.state.rows,onInput:this.onChangeRows,class:"input",type:"number",min:2,step:1,max:100}))),a.a.createElement("div",{class:"field"},a.a.createElement("label",{class:"label"},"Number of columns"),a.a.createElement("div",{class:"control"},a.a.createElement("input",{defaultValue:this.state.columns,onInput:this.onChangeColumns,class:"input",type:"number",min:2,step:1,max:100}))),a.a.createElement("div",{class:"field"},a.a.createElement("label",{class:"label"},"Price for one cell (REV)"),a.a.createElement("div",{class:"control"},a.a.createElement("input",{defaultValue:this.state.price,onChange:function(e){return n.setState({price:parseInt(e.target.value)})},class:"input",type:"number",min:1,step:1})),this.state&&this.state.price&&this.state.columns&&this.state.rows?a.a.createElement("p",null,"Total REV :"," ",wn.format(this.state.price*this.state.columns*this.state.rows)," ",a.a.createElement("br",null),"Total dust (1 dust is 1 REV divided by 100.000.000):"," ",wn.format(this.state.price*this.state.columns*this.state.rows*1e8)," "):void 0),a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-light",disabled:!(this.state&&this.state.price&&this.state.columns&&this.state.rows),type:"button",onClick:function(e){n.state&&n.state.price&&n.state.columns&&n.state.rows&&n.props.onValuesChosen({price:1e8*n.state.price,rows:n.state.rows,columns:n.state.columns,nonce:n.props.nonce})}},"Create canvas")))}}])&&Sn(e.prototype,t),r&&Sn(e,r),i}(a.a.Component);function xn(n){return(xn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function On(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Un(n,e){return(Un=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function Bn(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=Kn(n);if(e){var a=Kn(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return Pn(this,t)}}function Pn(n,e){return!e||"object"!==xn(e)&&"function"!=typeof e?jn(n):e}function jn(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function Kn(n){return(Kn=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var Vn=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&Un(n,e)}(i,n);var e,t,r,o=Bn(i);function i(n){var e,t,r,u;return function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,i),e=o.call(this,n),t=jn(e),u=function(n){n.pageX,e.el.current.getBoundingClientRect().left,n.pageY,e.el.current.getBoundingClientRect().top},(r="onClick")in t?Object.defineProperty(t,r,{value:u,enumerable:!0,configurable:!0,writable:!0}):t[r]=u,e.el=a.a.createRef(),e.colorInputEl=a.a.createRef(),e.state={color:"#444466",n:void 0,notAvailable:void 0},e}return e=i,(t=[{key:"componentDidMount",value:function(){var n=this;Cn(this.props.values.columns,this.props.values.rows,this.props.bagsData,this.props.bags,(function(e,t){var r=!1;Object.keys(n.props.bags).forEach((function(e){n.props.bags[e].n==="".concat(t)&&n.props.bags[e].price==n.props.values.price&&n.props.bags[e].quantity>0&&(r=!0,n.setState({n:"".concat(t),notAvailable:void 0}))})),r||n.setState({notAvailable:"".concat(t),n:void 0})}))}},{key:"render",value:function(){var n=this;return a.a.createElement("div",{className:"canvas-cont"},a.a.createElement("h2",{className:"title is-2"},"Fill the canvas !"),a.a.createElement("div",{id:"canvas",ref:this.el,className:"canvas"}),a.a.createElement("div",{className:"cell-form"},"string"==typeof this.state.notAvailable?a.a.createElement("p",{className:"has-text-danger"},"Cell ",this.state.notAvailable," is not available"):void 0,"string"==typeof this.state.n?a.a.createElement("div",{className:"n-and-color"},a.a.createElement("div",null,a.a.createElement("span",{className:"cell"},"Cell"),a.a.createElement("span",{className:"cell-n"},this.state.n),a.a.createElement("br",null),a.a.createElement("span",{className:"cell-available"},"Available"),a.a.createElement("br",null),a.a.createElement("span",{className:"cell-available"},"Price :"," ",a.a.createElement("b",null,wn.format(this.props.values.price/1e8)," REV"),a.a.createElement("br",null),wn.format(this.props.values.price)," dusts")),a.a.createElement("div",null,a.a.createElement("input",{ref:this.colorInputEl,type:"color",id:"body",name:"body",className:"color-input",defaultValue:"#444466",onChange:function(e){return n.setState({color:e.target.value})}}),a.a.createElement("div",{className:"color-box"},a.a.createElement("span",{className:"label"},"Color"),a.a.createElement("br",null),a.a.createElement("span",{style:{background:this.state.color||"#444466"},onClick:function(e){return n.colorInputEl.current.click()},className:"color-square"})),a.a.createElement("button",{className:"button is-white",disabled:!(this.state.color&&"string"==typeof this.state.n),type:"button",onClick:function(e){if(n.state.color&&"string"==typeof n.state.n){var t=Object.keys(n.props.bags).find((function(e){return n.props.bags[e].n===n.state.n&&n.props.bags[e].quantity>0&&n.props.bags[e].price===n.props.values.price}));n.props.onPurchase({bagId:t,color:n.state.color,price:n.props.values.price})}}},"Buy cell"))):void 0))}}])&&On(e.prototype,t),r&&On(e,r),i}(a.a.Component);function qn(n){return(qn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function $n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Ln(n,e){return(Ln=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function Mn(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=Hn(n);if(e){var a=Hn(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return Fn(this,t)}}function Fn(n,e){return!e||"object"!==qn(e)&&"function"!=typeof e?Gn(n):e}function Gn(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function Hn(n){return(Hn=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function Jn(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}var zn=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&Ln(n,e)}(i,n);var e,t,r,o=Mn(i);function i(n){var e;return function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,i),Jn(Gn(e=o.call(this,n)),"onValuesChosen",(function(n){if("undefined"!=typeof dappyRChain){for(var t="",r=n.columns*n.rows,a=0;a<r;a+=1)t+='"'.concat(a,'": { "publicKey": "').concat("PUBLIC"+"_KEY".substr(0),'", "n": "').concat(a,'", "price": ').concat(n.price,', "quantity": 1}').concat(a===r-1?"":",","\n");var o=blockchainUtils.generateNonce(),i=blockchainUtils.generateNonce(),s=Object(u.erc1155Term)(o,"PUBLIC"+"_KEY".substr(0)).replace("/*DEFAULT_BAGS*/",t).replace("/*OUTPUT_CHANNEL*/",'| erc1155OutputCh!({\n        "registryUri": *entryUri,\n      })'),c="\n   new entryCh, erc1155OutputCh, lookup(`rho:registry:lookup`), stdout(`rho:io:stdout`) in {\n\n     ".concat(s,' |\n\n     for (@output <- erc1155OutputCh) { \n       stdout!({\n         "rows": ').concat(n.rows,',\n         "price": ').concat(n.price,',\n         "columns": ').concat(n.columns,',\n         "erc1155RegistryUri": output.get("registryUri"),\n       }) |\n\n       lookup!(`rho:id:REGISTRY_URI`, *entryCh) |\n     \n       for(entry <- entryCh) {\n         entry!(\n           {\n             "type": "ADD",\n             "payload": {\n               "id": "values",\n               "file": {\n                 "rows": ').concat(n.rows,',\n                 "price": ').concat(n.price,',\n                 "columns": ').concat(n.columns,',\n                 "erc1155RegistryUri": output.get("registryUri"),\n               },\n               "nonce": "').concat(i,'",\n               "signature": "SIGNATURE"\n             }\n           },\n           *stdout\n         )\n       }\n     }\n   }\n   ');dappyRChain.transaction({term:c,signatures:{SIGNATURE:n.nonce}}).then((function(n){e.setState({modal:"values-chosen"})}))}else console.warn("window.dappyRChain is undefined, cannot deploy ERC1155")})),Jn(Gn(e),"onPurchase",(function(n){dappyRChain.transaction({term:Object(u.purchaseTokensTerm)(e.props.erc1155RegistryUri.replace("rho:id:",""),n.bagId,n.price,"".concat(n.color),1,"PUBLIC"+"_KEY".substr(0),blockchainUtils.generateNonce()),signatures:{}}).then((function(n){e.setState({modal:"purchase"})}))})),e.state={modal:void 0},e}return e=i,(t=[{key:"render",value:function(){var n=this;return"purchase"===this.state.modal?a.a.createElement("div",{className:"modal"},a.a.createElement("div",{className:"modal-background"}),a.a.createElement("div",{className:"modal-card"},a.a.createElement("header",{className:"modal-card-head"},a.a.createElement("p",{className:"modal-card-title"},"Purchase successful"),a.a.createElement("button",{onClick:function(){return n.setState({modal:void 0})},className:"delete","aria-label":"close"})),a.a.createElement("section",{className:"modal-card-body"},"Transaction was successfully sent. Wait few minutes, reload, and you should see your cell with the color you chose. Thank you for your participation."),a.a.createElement("footer",{className:"modal-card-foot"},a.a.createElement("button",{onClick:function(){return n.setState({modal:void 0})},class:"button"},"Ok")))):"genesis-form"===this.state.modal?a.a.createElement("div",{className:"modal"},a.a.createElement("div",{className:"modal-background"}),a.a.createElement("div",{className:"modal-card"},a.a.createElement("header",{className:"modal-card-head"},a.a.createElement("p",{className:"modal-card-title"},"Submit successful"),a.a.createElement("button",{onClick:function(){return n.setState({modal:void 0})},className:"delete","aria-label":"close"})),a.a.createElement("section",{className:"modal-card-body"},"Submit was successful, wait few minutes, reload, and the ERC-1155 contract should be initiated."),a.a.createElement("footer",{className:"modal-card-foot"},a.a.createElement("button",{onClick:function(){return n.setState({modal:void 0})},class:"button"},"Ok")))):this.props.values?a.a.createElement(Vn,{onPurchase:this.onPurchase,values:this.props.values,bagsData:this.props.bagsData,bags:this.props.bags}):a.a.createElement(In,{onValuesChosen:this.onValuesChosen,nonce:this.props.nonce})}}])&&$n(e.prototype,t),r&&$n(e,r),i}(a.a.Component);document.addEventListener("DOMContentLoaded",(function(){"undefined"!=typeof dappyRChain&&(window.dappy.address.includes("deltanetwork"),document.body.setAttribute("style",'background-image: url("dappy://deltanetwork/bmadyako1aq9xoegiy5iayq4mqxykrts8h7i9od1ed5krkfo9s6i4m.index");'),dappyRChain.fetch("dappy://REGISTRY_URI").then((function(n){var e=JSON.parse(n).expr[0],t=blockchainUtils.rhoValToJs(e);console.log(t),t.files.values?dappyRChain.exploreDeploys("dappy://explore-deploys",["new return,\n              fileCh,\n              fileCh,\n              filesModuleCh,\n              lookup(`rho:registry:lookup`) in {\n                lookup!(`".concat(t.files.values,"`, *fileCh) |\n                for(file <- fileCh) {\n                  return!(*file)\n                }\n            }")]).then((function(n){var e=JSON.parse(n).results,t=blockchainUtils.rhoValToJs(JSON.parse(e[0].data).expr[0]);console.log("files-module .values file retrieved with explore-deploy :"),console.log(t),dappyRChain.exploreDeploys("dappy://explore-deploys",["new return,\n                entryCh,\n                lookup(`rho:registry:lookup`)\n                in {\n                  lookup!(`".concat(t.erc1155RegistryUri,'`, *entryCh) |\n                  for(entry <- entryCh) {\n                    entry!(\n                      {\n                        "type": "READ_BAGS",\n                      },\n                      *return\n                    )\n                  }\n                }'),"new return,\n                entryCh,\n                lookup(`rho:registry:lookup`)\n                in {\n                  lookup!(`".concat(t.erc1155RegistryUri,'`, *entryCh) |\n                  for(entry <- entryCh) {\n                    entry!(\n                      {\n                        "type": "READ_BAGS_DATA",\n                      },\n                      *return\n                    )\n                  }\n                }')]).then((function(n){var e=JSON.parse(n).results,r=blockchainUtils.rhoValToJs(JSON.parse(e[0].data).expr[0]);console.log("ERC-1155 bags retrieved with explore-deploy :"),console.log(r);var o=blockchainUtils.rhoValToJs(JSON.parse(e[1].data).expr[0]);console.log("ERC-1155 bagsData retrieved with explore-deploy :"),console.log(o),document.getElementById("root").setAttribute("class","loaded"),i.a.render(a.a.createElement(zn,{values:t,bags:r,bagsData:o,erc1155RegistryUri:t.erc1155RegistryUri}),document.getElementById("root"))}))})):(document.getElementById("root").setAttribute("class","loaded"),i.a.render(a.a.createElement(zn,{nonce:t.nonce,values:void 0,bags:void 0,bagsData:void 0}),document.getElementById("root")))})).catch((function(n){console.error("Something went wrong when retreiving the files module object"),console.log(n)})))}))}]);